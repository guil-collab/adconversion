<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Frecuencia de muestreo, cuantización y reconstrucción — Animaciones didácticas</title>
<!--
README RÁPIDO
Escenas:
1) Señal continua vs muestreo
2) Aliasing
3) Comparación lado a lado
4) Nyquist visual
5) Escucha A/B (downsampling con/sin antialias)
6) Resolución en bits (cuantización): bits, dither, SNR teórico y error RMS, error de cuantización
7) Reconstrucción: ZOH (mal) vs interpolación suave (bien) + filtro de reconstrucción
-->
<style>
  :root{
    --bg:#0b0f14;--card:#111822;--ink:#e7f0ff;--muted:#a8c1ff88;--accent:#7aa2ff;--ok:#5bd38f;--warn:#ffd166;--bad:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;line-height:1.35}
  header{padding:20px 16px;text-align:center;border-bottom:1px solid #1b2533}
  header h1{margin:0;font-size:clamp(20px,3vw,28px)}
  header p{margin:.35rem 0 0;color:#c6d6ff99}

  main{display:grid;gap:18px;padding:18px;grid-template-columns:1fr;max-width:1200px;margin:0 auto}
  section.card{background:var(--card);border:1px solid #1b2533;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.22);overflow:hidden}
  .card header{border:none;text-align:left;background:linear-gradient(180deg,#0e1622,#0b111a);padding:14px 16px}
  .card header h2{margin:0;font-size:18px}
  .card header p{margin:.4rem 0 0;color:#c6d6ff80}
  .row{display:grid;gap:14px;padding:14px;grid-template-columns:1fr}
  .controls{display:flex;flex-wrap:wrap;gap:10px}
  .controls .ctl{background:#0e1520;border:1px solid #1b2533;border-radius:12px;padding:10px 12px;display:flex;align-items:center;gap:10px}
  .controls label{font-size:13px;opacity:.9;white-space:nowrap}
  input[type="range"]{accent-color:var(--accent)}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0f1928;border:1px solid #21324a;font-size:12px}
  .pill.ok{border-color:#214936;color:var(--ok);background:#0f1f17}
  .pill.warn{border-color:#4a4021;color:var(--warn);background:#1f1a0f}
  .pill.bad{border-color:#4a2121;color:var(--bad);background:#1f0f0f}
  .btn{cursor:pointer;border:1px solid #2a3954;background:#0f1928;color:var(--ink);padding:8px 12px;border-radius:10px}
  .btn:hover{background:#122136}
  canvas{width:100%;height:260px;background:#0a111a;border:1px solid #132033;border-radius:12px}
  .legend{display:flex;gap:12px;flex-wrap:wrap;font-size:12px;color:#c6d6ff90}
  .swatch{width:10px;height:10px;border-radius:2px;display:inline-block;margin-right:6px}
  .swatch.cont{background:#9ad1ff}
  .swatch.samp{background:#ffd166}
  .swatch.recon{background:#5bd38f}
  .swatch.quant{background:#ff9e9e}
  .grid-note{font-size:12px;color:#c6d6ff66}
  .kbd{background:#0f1928;border:1px solid #2a3954;border-radius:6px;padding:2px 6px;font-size:12px}
  select{background:#0f1928;color:var(--ink);border:1px solid #2a3954;border-radius:10px;padding:8px 12px}
  @media (min-width:900px){ .row.grid-2{grid-template-columns:1fr 1fr} }
</style>
</head>
<body>
<header>
  <h1>Sampling, Quantization & Reconstruction — Animaciones</h1>
  <p>Explora muestreo, aliasing, cuantización por bits (con dither) y reconstrucción ZOH vs interpolación.</p>
</header>

<main>

  <!-- Escenas 1–5: (idénticas a la última versión que te pasé) -->
  <!-- 1) Señal continua vs muestreo -->
  <section class="card" id="scene1">
    <header>
      <h2>1) Señal continua vs señal muestreada</h2>
      <p>Senoide de frecuencia <em>f</em> (continua) y sus muestras a <em>f<sub>s</sub></em>. Conexión lineal como reconstrucción simple.</p>
    </header>
    <div class="row">
      <div class="controls">
        <div class="ctl">
          <label>f (Hz)</label>
          <input type="range" id="s1_f" min="50" max="4000" step="10" value="1000">
          <span class="pill" id="s1_f_val">1000 Hz</span>
        </div>
        <div class="ctl">
          <label>f<sub>s</sub> (Hz)</label>
          <input type="range" id="s1_fs" min="2000" max="96000" step="100" value="44100">
          <span class="pill" id="s1_fs_val">44100 Hz</span>
        </div>
        <button class="btn" data-fs="8000">8 kHz</button>
        <button class="btn" data-fs="22050">22,05 kHz</button>
        <button class="btn" data-fs="44100">44,1 kHz</button>
        <button class="btn" data-fs="96000">96 kHz</button>
        <span class="pill ok" id="s1_nyq">Nyquist OK</span>
      </div>
      <div class="legend">
        <span><span class="swatch cont"></span>Señal continua</span>
        <span><span class="swatch samp"></span>Muestras</span>
        <span><span class="swatch recon"></span>Reconstrucción (lineal)</span>
      </div>
      <canvas id="s1_canvas" width="1000" height="260" aria-label="Señal vs muestreo"></canvas>
      <div class="grid-note">Rejilla = tiempo (x) y amplitud (y).</div>
    </div>
  </section>

  <!-- 2) Aliasing -->
  <section class="card" id="scene2">
    <header>
      <h2>2) Aliasing: cuando f<sub>s</sub> es insuficiente</h2>
      <p>La frecuencia “fantasma” aparece al muestrear por debajo de Nyquist. Calculamos y trazamos f<sub>alias</sub>.</p>
    </header>
    <div class="row">
      <div class="controls">
        <div class="ctl">
          <label>f (Hz)</label>
          <input type="range" id="s2_f" min="100" max="20000" step="10" value="12000">
          <span class="pill" id="s2_f_val">12000 Hz</span>
        </div>
        <div class="ctl">
          <label>f<sub>s</sub> (Hz)</label>
          <input type="range" id="s2_fs" min="2000" max="48000" step="100" value="8000">
          <span class="pill" id="s2_fs_val">8000 Hz</span>
        </div>
        <button class="btn" data-fs2="8000">8 kHz</button>
        <button class="btn" data-fs2="11025">11,025 kHz</button>
        <button class="btn" data-fs2="16000">16 kHz</button>
        <button class="btn" data-fs2="44100">44,1 kHz</button>
        <span class="pill warn" id="s2_alias_label">Alias activo</span>
      </div>
      <canvas id="s2_canvas" width="1000" height="260" aria-label="Aliasing"></canvas>
      <div class="grid-note">f<sub>alias</sub> = | ((f + f<sub>s</sub>/2) mod f<sub>s</sub>) − f<sub>s</sub>/2 | → <strong id="s2_alias_val"></strong></div>
    </div>
  </section>

  <!-- 3) Comparación lado a lado -->
  <section class="card" id="scene3">
    <header>
      <h2>3) Comparación lado a lado</h2>
      <p>Misma señal a 44,1 kHz vs 8 kHz.</p>
    </header>
    <div class="row grid-2">
      <div>
        <div class="controls">
          <div class="ctl">
            <label>f (Hz)</label>
            <input type="range" id="s3_f" min="50" max="6000" step="10" value="1500">
            <span class="pill" id="s3_f_val">1500 Hz</span>
          </div>
        </div>
        <div class="legend">
          <span><span class="swatch cont"></span>Señal continua</span>
          <span><span class="swatch samp"></span>Muestras</span>
        </div>
        <canvas id="s3_left" width="1000" height="220" aria-label="44.1 kHz"></canvas>
        <div class="grid-note">f<sub>s</sub> = 44,1 kHz.</div>
      </div>
      <div>
        <div class="legend" style="margin-top:42px">
          <span><span class="swatch cont"></span>Señal continua</span>
          <span><span class="swatch samp"></span>Muestras</span>
        </div>
        <canvas id="s3_right" width="1000" height="220" aria-label="8 kHz"></canvas>
        <div class="grid-note">f<sub>s</sub> = 8 kHz. <span id="s3_warn" class="pill warn" style="margin-left:6px">Posible aliasing</span></div>
      </div>
    </div>
  </section>

  <!-- 4) Nyquist visual -->
  <section class="card" id="scene4">
    <header>
      <h2>4) Regla de Nyquist</h2>
      <p>Para evitar aliasing, f<sub>s</sub> ≥ 2 × f<sub>max</sub>. Ajusta la banda y f<sub>s</sub>.</p>
    </header>
    <div class="row">
      <div class="controls">
        <div class="ctl">
          <label>f<sub>max</sub> (Hz)</label>
          <input type="range" id="s4_fmax" min="1000" max="24000" step="100" value="20000">
          <span class="pill" id="s4_fmax_val">20000 Hz</span>
        </div>
        <div class="ctl">
          <label>f<sub>s</sub> (Hz)</label>
          <input type="range" id="s4_fs" min="4000" max="96000" step="100" value="44100">
          <span class="pill" id="s4_fs_val">44100 Hz</span>
        </div>
        <span class="pill ok" id="s4_state">Nyquist OK</span>
      </div>
      <canvas id="s4_canvas" width="1000" height="220" aria-label="Nyquist"></canvas>
      <div class="grid-note">Franja azul: 0–f<sub>max</sub>. Barra amarilla: f<sub>s</sub>/2.</div>
    </div>
  </section>

  <!-- 5) Escucha comparativa (Web Audio) -->
  <section class="card" id="scene5">
    <header>
      <h2>5) Escucha A/B: downsampling simulado (con/sin antialias)</h2>
      <p>Fuente sintética → decimación a 22,05 kHz o 8 kHz, con y sin filtro previo.</p>
    </header>
    <div class="row">
      <div class="controls">
        <div class="ctl">
          <label>Fuente: f1 (Hz)</label>
          <input type="range" id="s5_f1" min="300" max="6000" step="10" value="1000">
          <span class="pill" id="s5_f1_val">1000 Hz</span>
        </div>
        <div class="ctl">
          <label>f2 (Hz)</label>
          <input type="range" id="s5_f2" min="800" max="12000" step="10" value="5000">
          <span class="pill" id="s5_f2_val">5000 Hz</span>
        </div>
        <button class="btn" id="s5_generate">Generar fuente</button>
      </div>
      <div class="controls">
        <div class="ctl">
          <label>Modo</label>
          <select id="s5_mode">
            <option value="orig">Original</option>
            <option value="ds_22050_noaa">22,05 kHz (sin antialias)</option>
            <option value="ds_22050_aa">22,05 kHz (con antialias)</option>
            <option value="ds_8000_noaa">8 kHz (sin antialias)</option>
            <option value="ds_8000_aa">8 kHz (con antialias)</option>
          </select>
        </div>
        <button class="btn" id="s5_play">Reproducir</button>
        <button class="btn" id="s5_stop">Parar</button>
        <button class="btn" id="s5_ab">A/B</button>
        <span class="pill" id="s5_status">Listo</span>
      </div>
      <div class="grid-note"><strong>Sin antialias</strong> ⇒ aliasing audible. <strong>Con antialias</strong> ⇒ filtro LP antes de decimar.</div>
    </div>
  </section>

  <!-- 6) Resolución en bits (cuantización) -->
  <section class="card" id="scene6">
    <header>
      <h2>6) Resolución en bits (cuantización)</h2>
      <p>Visualiza los escalones de cuantización, el error y la SNR teórica vs medida. Activa <em>dither</em> para “descorrelacionar” el error.</p>
    </header>
    <div class="row">
      <div class="controls">
        <div class="ctl">
          <label>f señal (Hz)</label>
          <input type="range" id="s6_f" min="50" max="4000" step="10" value="1000">
          <span class="pill" id="s6_f_val">1000 Hz</span>
        </div>
        <div class="ctl">
          <label>Bits</label>
          <input type="range" id="s6_bits" min="2" max="24" step="1" value="8">
          <span class="pill" id="s6_bits_val">8 bits</span>
        </div>
        <div class="ctl">
          <label><input type="checkbox" id="s6_dither"> Dither TPDF</label>
          <span class="pill warn" id="s6_snr_lbl">SNR teórica: —</span>
          <span class="pill" id="s6_err_lbl">Error RMS: —</span>
        </div>
      </div>
      <div class="legend">
        <span><span class="swatch cont"></span>Señal continua</span>
        <span><span class="swatch quant"></span>Señal cuantizada</span>
      </div>
      <canvas id="s6_canvas" width="1000" height="260" aria-label="Cuantización"></canvas>
      <canvas id="s6_err_canvas" width="1000" height="120" aria-label="Error de cuantización" style="height:140px"></canvas>
      <div class="grid-note">
        Paso de cuantización Δ = 2 / 2<sup>N</sup> (rango ±1). SNR<sub>teo</sub> ≈ 6.02·N + 1.76 dB (seno a 0 dBFS).
      </div>
    </div>
  </section>

  <!-- 7) Reconstrucción: ZOH vs interpolación -->
  <section class="card" id="scene7">
    <header>
      <h2>7) Reconstrucción: ZOH (mal) vs interpolación suave (bien)</h2>
      <p>Las muestras por sí solas no son audio continuo. Compara <em>hold</em> (ZOH) con una interpolación suave (aprox. sinc) y observa el efecto de un filtro de reconstrucción.</p>
    </header>
    <div class="row">
      <div class="controls">
        <div class="ctl">
          <label>f señal (Hz)</label>
          <input type="range" id="s7_f" min="50" max="4000" step="10" value="1200">
          <span class="pill" id="s7_f_val">1200 Hz</span>
        </div>
        <div class="ctl">
          <label>f<sub>s</sub> (Hz)</label>
          <input type="range" id="s7_fs" min="4000" max="48000" step="100" value="16000">
          <span class="pill" id="s7_fs_val">16000 Hz</span>
        </div>
        <div class="ctl">
          <label>Reconstrucción</label>
          <select id="s7_mode">
            <option value="zoh">ZOH (sample & hold)</option>
            <option value="zoh_lp">ZOH + filtro de reconstrucción</option>
            <option value="interp">Interpolación suave (aprox. sinc)</option>
          </select>
        </div>
        <span class="pill bad" id="s7_bad">ZOH: incorrecta (escalonada)</span>
        <span class="pill ok" id="s7_good">Interpolación: correcta (suave)</span>
      </div>
      <div class="legend">
        <span><span class="swatch samp" style="background:#ffd166"></span>Muestras</span>
        <span><span class="swatch recon" style="background:#5bd38f"></span>Reconstrucción</span>
        <span><span class="swatch cont" style="background:#9ad1ff"></span>Señal original</span>
      </div>
      <canvas id="s7_canvas" width="1000" height="260" aria-label="Reconstrucción"></canvas>
      <div class="grid-note">El filtro de reconstrucción (LP) suaviza la ZOH y elimina imágenes espectrales por encima de Nyquist.</div>
    </div>
  </section>

</main>

<script>
/* ==== Utilidades comunes ==== */
function drawGrid(ctx, w, h, xDiv=10, yDiv=4){
  ctx.save(); ctx.strokeStyle = '#183048'; ctx.lineWidth = 1; ctx.beginPath();
  for(let i=1;i<xDiv;i++){ const x=(i/xDiv)*w; ctx.moveTo(x,0); ctx.lineTo(x,h); }
  for(let j=1;j<yDiv;j++){ const y=(j/yDiv)*h; ctx.moveTo(0,y); ctx.lineTo(w,y); }
  ctx.stroke(); ctx.restore();
}
function toScreen(x,y,w,h,xmin,xmax,ymin=-1,ymax=1){
  const sx=(x-xmin)/(xmax-xmin)*w, sy=h-((y-ymin)/(ymax-ymin)*h); return [sx,sy];
}
function drawContinuous(ctx,w,h,f,tspan,amp=0.9,color='#9ad1ff',dash=null){
  ctx.save(); ctx.lineWidth=2; ctx.strokeStyle=color; if(dash) ctx.setLineDash(dash);
  ctx.beginPath(); const N=1200;
  for(let i=0;i<=N;i++){
    const t=i/N*tspan, y=amp*Math.sin(2*Math.PI*f*t); const [sx,sy]=toScreen(t,y,w,h,0,tspan,-1,1);
    if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
  } ctx.stroke(); ctx.restore();
}
function drawSamples(ctx,w,h,pts,tspan,ymin=-1,ymax=1){
  ctx.save();
  ctx.fillStyle='#ffd166';
  for(const [t,y] of pts){
    const [sx,sy]=toScreen(t,y,w,h,0,tspan,ymin,ymax);
    ctx.beginPath(); ctx.arc(sx,sy,3.5,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}
function aliasFreq(f,fs){ const v=((f+fs/2)%fs)-fs/2; return Math.abs(v); }

/* ==== 1) Señal continua vs muestreo ==== */
(function(){
  const canvas=document.getElementById('s1_canvas'); const ctx=canvas.getContext('2d');
  const fS=document.getElementById('s1_f'), fsS=document.getElementById('s1_fs');
  const fVal=document.getElementById('s1_f_val'), fsVal=document.getElementById('s1_fs_val'), nyq=document.getElementById('s1_nyq');
  document.querySelectorAll('#scene1 .btn').forEach(b=>b.addEventListener('click',()=>{ fsS.value=b.dataset.fs; render(); }));
  function render(){
    const w=canvas.width,h=canvas.height,f=+fS.value,fs=+fsS.value;
    fVal.textContent=`${f} Hz`; fsVal.textContent=`${fs} Hz`;
    const ok=fs>=2*f; nyq.textContent=ok?'Nyquist OK':'Por debajo de Nyquist'; nyq.className='pill '+(ok?'ok':'bad');
    const tspan=7/f;
    ctx.clearRect(0,0,w,h); drawGrid(ctx,w,h,12,4); drawContinuous(ctx,w,h,f,tspan);
    // muestras y reconstrucción lineal
    const dt=1/fs; const pts=[]; for(let t=0;t<=tspan+1e-9;t+=dt){ pts.push([t,0.9*Math.sin(2*Math.PI*f*t)]); }
    // conexión lineal
    ctx.save(); ctx.lineWidth=1.8; ctx.strokeStyle='#5bd38f'; ctx.beginPath();
    pts.forEach(([t,y],i)=>{ const [sx,sy]=toScreen(t,y,w,h,0,tspan,-1,1); if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);});
    ctx.stroke(); ctx.restore();
    drawSamples(ctx,w,h,pts,tspan);
  }
  fS.addEventListener('input',render); fsS.addEventListener('input',render); render();
})();

/* ==== 2) Aliasing ==== */
(function(){
  const canvas=document.getElementById('s2_canvas'); const ctx=canvas.getContext('2d');
  const fS=document.getElementById('s2_f'), fsS=document.getElementById('s2_fs');
  const fVal=document.getElementById('s2_f_val'), fsVal=document.getElementById('s2_fs_val');
  const aliasLabel=document.getElementById('s2_alias_label'), aliasOut=document.getElementById('s2_alias_val');
  document.querySelectorAll('#scene2 .btn').forEach(b=>b.addEventListener('click',()=>{ fsS.value=b.dataset.fs2; render(); }));
  function render(){
    const w=canvas.width,h=canvas.height,f=+fS.value,fs=+fsS.value;
    fVal.textContent=`${f} Hz`; fsVal.textContent=`${fs} Hz`;
    const fal=aliasFreq(f,fs); aliasOut.textContent=`${fal.toFixed(1)} Hz`;
    const ok=fs>=2*f; aliasLabel.textContent= ok? 'Nyquist OK (sin aliasing)' : `Alias: ${fal.toFixed(1)} Hz`;
    aliasLabel.className='pill '+(ok?'ok':'warn');
    const fShow= ok? f : Math.max(fal,1); const tspan=Math.min(8/fShow,0.02);
    ctx.clearRect(0,0,w,h); drawGrid(ctx,w,h,12,4); drawContinuous(ctx,w,h,f,tspan);
    // muestras + reconexión
    const dt=1/fs; const pts=[]; for(let t=0;t<=tspan+1e-9;t+=dt){ pts.push([t,0.9*Math.sin(2*Math.PI*f*t)]); }
    ctx.save(); ctx.lineWidth=1.8; ctx.strokeStyle='#5bd38f'; ctx.beginPath();
    pts.forEach(([t,y],i)=>{ const [sx,sy]=toScreen(t,y,w,h,0,tspan,-1,1); if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);}); ctx.stroke(); ctx.restore();
    drawSamples(ctx,w,h,pts,tspan);
    if(!ok){ drawContinuous(ctx,w,h, fal, tspan, 0.9, '#5bd38f', [8,6]); }
  }
  fS.addEventListener('input',render); fsS.addEventListener('input',render); render();
})();

/* ==== 3) Comparación lado a lado ==== */
(function(){
  const lctx=document.getElementById('s3_left').getContext('2d');
  const rctx=document.getElementById('s3_right').getContext('2d');
  const fS=document.getElementById('s3_f'), fVal=document.getElementById('s3_f_val'), warn=document.getElementById('s3_warn');
  function draw(ctx,fs){
    const c=ctx.canvas,w=c.width,h=c.height,f=+fS.value,ok=fs>=2*f;
    if(warn && fs===8000){ warn.textContent=ok?'Nyquist OK':'Posible aliasing'; warn.className='pill '+(ok?'ok':'warn'); }
    const tspan=7/f;
    ctx.clearRect(0,0,w,h); drawGrid(ctx,w,h,10,4); drawContinuous(ctx,w,h,f,tspan); 
    const dt=1/fs; const pts=[]; for(let t=0;t<=tspan+1e-9;t+=dt){ pts.push([t,0.9*Math.sin(2*Math.PI*f*t)]); }
    drawSamples(ctx,w,h,pts,tspan);
  }
  function render(){ const f=+fS.value; fVal.textContent=`${f} Hz`; draw(lctx,44100); draw(rctx,8000); }
  fS.addEventListener('input',render); render();
})();

/* ==== 4) Nyquist visual ==== */
(function(){
  const canvas=document.getElementById('s4_canvas'); const ctx=canvas.getContext('2d');
  const fmaxS=document.getElementById('s4_fmax'), fsS=document.getElementById('s4_fs');
  const fmaxVal=document.getElementById('s4_fmax_val'), fsVal=document.getElementById('s4_fs_val'), state=document.getElementById('s4_state');
  function render(){
    const w=canvas.width,h=canvas.height,fmax=+fmaxS.value,fs=+fsS.value; fmaxVal.textContent=`${fmax} Hz`; fsVal.textContent=`${fs} Hz`;
    const ny=fs/2, ok=ny>=fmax; state.textContent=ok?'Nyquist OK':'Insuficiente (aliasing)'; state.className='pill '+(ok?'ok':'bad');
    ctx.clearRect(0,0,w,h); drawGrid(ctx,w,h,12,1);
    const fmaxView=24000;
    ctx.save(); ctx.fillStyle='#9ad1ff33'; const x1=(Math.min(fmax,fmaxView)/fmaxView)*w;
    ctx.fillRect(0,h*0.25,x1,h*0.5); ctx.strokeStyle='#9ad1ff'; ctx.strokeRect(0,h*0.25,x1,h*0.5); ctx.restore();
    ctx.save(); ctx.strokeStyle='#ffd166'; ctx.lineWidth=3; const xNy=(Math.min(ny,fmaxView)/fmaxView)*w;
    ctx.beginPath(); ctx.moveTo(xNy,h*0.18); ctx.lineTo(xNy,h*0.82); ctx.stroke();
    ctx.fillStyle='#ffd166'; ctx.font='12px system-ui'; ctx.fillText(`f_s/2 = ${Math.round(ny)} Hz`, Math.min(w-140,xNy+6), 18); ctx.restore();
    ctx.save(); ctx.fillStyle='#c6d6ff88'; ctx.font='12px system-ui'; for(let k=0;k<=24;k+=4){ const x=(k/24)*w; ctx.fillText(`${k} kHz`, x+4, h-6);} ctx.restore();
  }
  fmaxS.addEventListener('input',render); fsS.addEventListener('input',render); render();
})();

/* ==== 5) Web Audio: downsampling A/B ==== */
(function(){
  const f1S=document.getElementById('s5_f1'), f2S=document.getElementById('s5_f2');
  const f1Val=document.getElementById('s5_f1_val'), f2Val=document.getElementById('s5_f2_val');
  const genBtn=document.getElementById('s5_generate'), playBtn=document.getElementById('s5_play'), stopBtn=document.getElementById('s5_stop'), abBtn=document.getElementById('s5_ab');
  const modeSel=document.getElementById('s5_mode'), statusEl=document.getElementById('s5_status');

  let ctxA=null, srcA=null, srcB=null, gA=null, gB=null, running=false, abToggle=false;
  let bufOrig=null, bufProc=null;

  function setStatus(txt){ statusEl.textContent=txt; }
  function mkContext(){ if(!ctxA) ctxA=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'}); return ctxA; }
  function makeSource(buf){ const s=ctxA.createBufferSource(); s.buffer=buf; s.loop=true; const g=ctxA.createGain(); g.gain.value=1; s.connect(g).connect(ctxA.destination); return {s,g}; }
  function genSourceBuffer(fs, durSec=1.0){
    const ch=1; const buf=ctxA.createBuffer(ch, Math.floor(fs*durSec), fs); const data=buf.getChannelData(0);
    const f1=+f1S.value, f2=+f2S.value; const a1=0.7, a2=0.5;
    for(let n=0;n<data.length;n++){ const t=n/fs; data[n]=Math.tanh(1.5*(a1*Math.sin(2*Math.PI*f1*t)+a2*Math.sin(2*Math.PI*f2*t))); }
    return buf;
  }
  function lowpassFIR(cutoffNorm, taps=101){ const M=taps-1; const h=new Float32Array(taps); const fc=cutoffNorm;
    for(let n=0;n<taps;n++){ const m=n-M/2; const w=0.5*(1-Math.cos(2*Math.PI*n/M)); const sinc=(m===0)? 2*Math.PI*fc : Math.sin(2*Math.PI*fc*m)/m; h[n]=w*sinc/Math.PI; }
    let sum=0; for(let i=0;i<taps;i++) sum+=h[i]; for(let i=0;i<taps;i++) h[i]/=sum; return h;
  }
  function convolveFIR(input, h){ const N=input.length,M=h.length,out=new Float32Array(N); for(let n=0;n<N;n++){ let acc=0; for(let k=0;k<M;k++){ const i=n-k; if(i>=0) acc+=h[k]*input[i]; } out[n]=acc; } return out; }
  function decimateHold(input, R){ const N=Math.floor(input.length/R); const low=new Float32Array(N); for(let i=0;i<N;i++) low[i]=input[i*R];
    const out=new Float32Array(N*R); for(let i=0;i<i*0+N;i++) for(let r=0;r<R;r++) out[i*R+r]=low[i]; return out; }
  function processDownsample(buf, targetFs, useAA){
    const fs=buf.sampleRate; const R=Math.round(fs/targetFs); const data=buf.getChannelData(0); let x=data;
    if(useAA){ const cutoff=(targetFs/2)/fs; const h=lowpassFIR(cutoff*0.95, 101); x=convolveFIR(data,h); }
    const out=decimateHold(x,R); const newBuf=ctxA.createBuffer(1,out.length,fs); newBuf.copyToChannel(out,0,0); return newBuf;
  }
  function build(){ mkContext(); bufOrig=genSourceBuffer(ctxA.sampleRate,1.0); const mode=modeSel.value; if(mode==='orig'){ bufProc=null; return; }
    const map={'ds_22050_noaa':[22050,false],'ds_22050_aa':[22050,true],'ds_8000_noaa':[8000,false],'ds_8000_aa':[8000,true]}; const [tFs,aa]=map[mode]; bufProc=processDownsample(bufOrig,tFs,aa); }
  function stopAll(){ try{srcA?.s.stop()}catch{} try{srcB?.s.stop()}catch{} srcA=srcB=gA=gB=null; running=false; setStatus('Parado'); }
  function play(){ if(!bufOrig){ setStatus('Genera la fuente'); return; } stopAll(); srcA=makeSource(bufOrig); gA=srcA.g; gA.gain.value=abToggle?0:1; if(bufProc){ srcB=makeSource(bufProc); gB=srcB.g; gB.gain.value=abToggle?1:0; }
    srcA.s.start(); if(srcB) srcB.s.start(); running=true; setStatus(`Reproduciendo (${abToggle? 'Procesado':'Original'})`); }
  function ab(){ if(!running) return setStatus('No está reproduciendo'); if(!bufProc) return setStatus('Modo original (sin B)'); abToggle=!abToggle; if(gA&&gB){ gA.gain.value=abToggle?0:1; gB.gain.value=abToggle?1:0; } setStatus(`A/B → escuchas: ${abToggle?'Procesado':'Original'}`); }

  f1S.addEventListener('input',()=>{ f1Val.textContent=`${f1S.value} Hz`; });
  f2S.addEventListener('input',()=>{ f2Val.textContent=`${f2S.value} Hz`; });
  genBtn.addEventListener('click',()=>{ build(); setStatus('Fuente generada'); });
  modeSel.addEventListener('change',()=>{ if(bufOrig){ build(); if(running){ play(); } } });
  playBtn.addEventListener('click', async()=>{ mkContext(); await ctxA.resume(); if(!bufOrig) build(); play(); });
  stopBtn.addEventListener('click', stopAll);
  abBtn.addEventListener('click', ab);
  f1Val.textContent=`${f1S.value} Hz`; f2Val.textContent=`${f2S.value} Hz`;
})();

/* ==== 6) Resolución en bits (cuantización) ==== */
(function(){
  const cMain = document.getElementById('s6_canvas').getContext('2d');
  const cErr  = document.getElementById('s6_err_canvas').getContext('2d');
  const fS = document.getElementById('s6_f');
  const bitsS = document.getElementById('s6_bits');
  const ditherCk = document.getElementById('s6_dither');
  const fVal = document.getElementById('s6_f_val');
  const bitsVal = document.getElementById('s6_bits_val');
  const snrLbl = document.getElementById('s6_snr_lbl');
  const errLbl = document.getElementById('s6_err_lbl');

  function quantize(x, bits){
    const levels = Math.pow(2, bits);
    const step = 2/levels; // rango [-1,1)
    // mapea x∈[-1,1] a índices 0..levels-1 y viceversa (mid-tread)
    const idx = Math.round((x+1)/step - 0.5);
    const q = ( (idx+0.5)*step - 1 );
    return Math.max(-1, Math.min(1, q)); // clip por seguridad
  }
  function tpdfDither(step){
    // TPDF: suma de dos uniformes [-0.5,0.5] * step
    const u1 = Math.random()-0.5, u2 = Math.random()-0.5;
    return (u1+u2)*step;
  }

  function render(){
    const w=cMain.canvas.width, h=cMain.canvas.height;
    const we=cErr.canvas.width, he=cErr.canvas.height;
    const f=+fS.value, bits=+bitsS.value; fVal.textContent=`${f} Hz`; bitsVal.textContent=`${bits} bits`;

    const snrTheo = 6.02*bits + 1.76; snrLbl.textContent = `SNR teórica: ${snrTheo.toFixed(1)} dB`;

    // Ventana temporal: ~5 ciclos
    const tspan = 5/f;
    const N = 2000; // puntos densos para trazar continuo
    const levels = Math.pow(2,bits);
    const step = 2/levels;

    const ptsCont = [];
    const ptsQuant = [];
    const err = [];
    let sigP2=0, errP2=0;

    for(let i=0;i<=N;i++){
      const t = i/N * tspan;
      const y = 0.9*Math.sin(2*Math.PI*f*t);
      // dither (a la señal antes de cuantizar)
      const yD = ditherCk.checked ? Math.max(-1, Math.min(1, y + tpdfDither(step))) : y;
      const yq = quantize(yD, bits);
      ptsCont.push([t,y]);
      ptsQuant.push([t,yq]);
      const e = yq - y; err.push([t,e]);
      sigP2 += y*y;
      errP2 += e*e;
    }
    const snrMeas = 10*Math.log10(sigP2/Math.max(1e-12,errP2));
    errLbl.textContent = `Error RMS: ${(Math.sqrt(errP2/(N+1))).toFixed(4)} (SNR med: ${snrMeas.toFixed(1)} dB)`;

    // Dibujar principal
    cMain.clearRect(0,0,w,h); drawGrid(cMain,w,h,12,4);
    // continuo
    cMain.save(); cMain.strokeStyle='#9ad1ff'; cMain.lineWidth=2; cMain.beginPath();
    ptsCont.forEach(([t,y],i)=>{ const [sx,sy]=toScreen(t,y,w,h,0,tspan,-1,1); if(i===0)cMain.moveTo(sx,sy); else cMain.lineTo(sx,sy); });
    cMain.stroke(); cMain.restore();
    // cuantizado (escalones)
    cMain.save(); cMain.strokeStyle='#ff9e9e'; cMain.lineWidth=2;
    cMain.beginPath();
    for(let i=0;i<ptsQuant.length-1;i++){
      const [t1,y1]=ptsQuant[i], [t2,y2]=ptsQuant[i+1];
      const [x1,yy1]=toScreen(t1,y1,w,h,0,tspan,-1,1);
      const [x2,yy2]=toScreen(t2,y2,w,h,0,tspan,-1,1);
      // tramo horizontal (hold)
      cMain.moveTo(x1,yy1); cMain.lineTo(x2,yy1);
      // salto vertical al siguiente nivel
      if(y2!==y1){ cMain.moveTo(x2,yy1); cMain.lineTo(x2,yy2); }
    }
    cMain.stroke(); cMain.restore();

    // Error de cuantización
    cErr.clearRect(0,0,we,he); drawGrid(cErr,we,he,12,2);
    cErr.save(); cErr.strokeStyle='#ffd166'; cErr.lineWidth=1.5; cErr.beginPath();
    err.forEach(([t,e],i)=>{ const [sx,sy]=toScreen(t,e,we,he,0,tspan,-0.2,0.2); if(i===0)cErr.moveTo(sx,sy); else cErr.lineTo(sx,sy); });
    cErr.stroke(); cErr.restore();

    // Rejilla de niveles (opcional): dibuja líneas de cuantización
    cMain.save(); cMain.strokeStyle='#23364f'; cMain.lineWidth=1;
    for(let k=-(levels/2); k<=levels/2; k++){
      const y = (k+0.5)*step - 1; if(y<-1 || y>1) continue;
      const [x1,yy]=toScreen(0,y,w,h,0,tspan,-1,1); const [x2]=toScreen(tspan,y,w,h,0,tspan,-1,1);
      cMain.beginPath(); cMain.moveTo(x1,yy); cMain.lineTo(x2,yy); cMain.stroke();
    }
    cMain.restore();
  }

  fS.addEventListener('input', render);
  bitsS.addEventListener('input', render);
  ditherCk.addEventListener('change', render);
  render();
})();

/* ==== 7) Reconstrucción: ZOH vs interpolación ==== */
(function(){
  const ctx = document.getElementById('s7_canvas').getContext('2d');
  const fS = document.getElementById('s7_f');
  const fsS = document.getElementById('s7_fs');
  const modeSel = document.getElementById('s7_mode');
  const fVal = document.getElementById('s7_f_val');
  const fsVal = document.getElementById('s7_fs_val');
  const bad = document.getElementById('s7_bad');
  const good = document.getElementById('s7_good');

  function lowpassFIR(cutoffNorm, taps=101){
    const M=taps-1; const h=new Float32Array(taps); const fc=cutoffNorm;
    for(let n=0;n<taps;n++){
      const m=n-M/2; const w=0.5*(1-Math.cos(2*Math.PI*n/M)); const sinc=(m===0)? 2*Math.PI*fc : Math.sin(2*Math.PI*fc*m)/m;
      h[n]=w*sinc/Math.PI;
    }
    let sum=0; for(let i=0;i<taps;i++) sum+=h[i]; for(let i=0;i<taps;i++) h[i]/=sum;
    return h;
  }
  function convolveFIR(sig, h){
    const N=sig.length, M=h.length; const out=new Float32Array(N);
    for(let n=0;n<N;n++){ let acc=0; for(let k=0;k<M;k++){ const i=n-k; if(i>=0) acc+=h[k]*sig[i]; } out[n]=acc; }
    return out;
  }

  function render(){
    const w=ctx.canvas.width, h=ctx.canvas.height;
    const f=+fS.value, fs=+fsS.value; fVal.textContent=`${f} Hz`; fsVal.textContent=`${fs} Hz`;

    const tspan=7/f; // mostrar ~7 ciclos
    const dt=1/fs;
    const pts=[]; for(let t=0;t<=tspan+1e-9;t+=dt){ pts.push([t,0.9*Math.sin(2*Math.PI*f*t)]); }

    ctx.clearRect(0,0,w,h); drawGrid(ctx,w,h,12,4);
    // Señal original (referencia)
    drawContinuous(ctx,w,h,f,tspan,0.9,'#9ad1ff');

    // Muestras
    drawSamples(ctx,w,h,pts,tspan);

    // Reconstrucción
    const mode = modeSel.value;
    if(mode==='zoh' || mode==='zoh_lp'){
      // Zero-Order Hold
      ctx.save(); ctx.strokeStyle='#5bd38f'; ctx.lineWidth=2;
      ctx.beginPath();
      for(let i=0;i<pts.length-1;i++){
        const [t1,y1]=pts[i], [t2,y2]=pts[i+1];
        const [x1,yy1]=toScreen(t1,y1,w,h,0,tspan,-1,1);
        const [x2,yy2]=toScreen(t2,y2,w,h,0,tspan,-1,1);
        ctx.moveTo(x1,yy1); ctx.lineTo(x2,yy1);
      }
      ctx.stroke(); ctx.restore();

      if(mode==='zoh_lp'){
        // “Filtro de reconstrucción”: aplicar LP a una señal discretizada re-muestreada densa
        const R=8; // upsample para mostrar suavizado
        const denseN = (pts.length-1)*R+1;
        const dense = new Float32Array(denseN);
        for(let i=0;i<pts.length-1;i++){
          for(let r=0;r<R;r++){ dense[i*R+r] = pts[i][1]; }
        }
        dense[denseN-1] = pts[pts.length-1][1];
        const hF = lowpassFIR(0.45/R, 101);
        const smooth = convolveFIR(dense, hF);
        // dibujar suavizado
        ctx.save(); ctx.strokeStyle='#36d39a'; ctx.lineWidth=2; ctx.setLineDash([6,4]);
        ctx.beginPath();
        for(let i=0;i<denseN;i++){
          const t = (i/(denseN-1))*tspan;
          const [sx,sy]=toScreen(t, smooth[i], w,h,0,tspan,-1,1);
          if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
        }
        ctx.stroke(); ctx.restore();
      }

      bad.style.display='inline-flex'; good.style.display='none';
    }else{
      // Interpolación suave (aprox. sinc): LERP denso + LP para suavizar
      const R=16;
      const denseN=(pts.length-1)*R+1;
      const dense=new Float32Array(denseN);
      for(let i=0;i<pts.length-1;i++){
        const y1=pts[i][1], y2=pts[i+1][1];
        for(let r=0;r<R;r++){ const a=r/R; dense[i*R+r] = y1*(1-a)+y2*a; }
      }
      dense[denseN-1]=pts[pts.length-1][1];
      const hF = lowpassFIR(0.48/R, 101);
      const smooth = convolveFIR(dense, hF);

      ctx.save(); ctx.strokeStyle='#5bd38f'; ctx.lineWidth=2;
      ctx.beginPath();
      for(let i=0;i<denseN;i++){
        const t=(i/(denseN-1))*tspan;
        const [sx,sy]=toScreen(t, smooth[i], w,h,0,tspan,-1,1);
        if(i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
      }
      ctx.stroke(); ctx.restore();

      bad.style.display='none'; good.style.display='inline-flex';
    }
  }

  fS.addEventListener('input', render);
  fsS.addEventListener('input', render);
  modeSel.addEventListener('change', render);
  render();
})();
</script>
</body>
</html>
